class Base{constructor(){this._allowedOperators=["$in","$nin","$regex","$and","$not"]}_ruleTypeAllowed(e){return this._allowedOperators.includes(e)}_isString(e){return"string"==typeof e}_isObject(e){return!Array.isArray(e)&&"object"==typeof e}_isArray(e){return Array.isArray(e)}_isRuleType(e,r){try{return this._isObject(r)&&e in r}catch(e){throw e}}}class ErrorPermissionEngine extends Error{constructor(e="",...r){super(e,...r),this.message=e}}class PermissionEngine extends Base{constructor(){super()}_ruleType$regex(r,e){try{return e.some(e=>r.test(e))}catch(e){throw e}}_ruleType$in(e,r){const n=this;try{return e.some(e=>{if(n._isString(e))return r.includes(e);if(n._isRuleType("$regex",e))return n._ruleType$regex(e.$regex,r);throw new ErrorPermissionEngine(`Rule ${JSON.stringify(e)} not allow`)})}catch(e){throw e}}_ruleType$and(e,r){const n=this;try{return e.every(e=>{if(n._isString(e))return r.includes(e);if(n._isRuleType("$in",e))return n._ruleType$in(e.$in,r);if(n._isRuleType("$nin",e))return!n._ruleType$in(e.$nin,r);if(n._isRuleType("$and",e))return n._ruleType$and(e.$and,r);if(n._isRuleType("$not",e))return!n._ruleType$and(e.$not,r);if(n._isRuleType("$regex",e))return n._ruleType$regex(e.$regex,r);throw new ErrorPermissionEngine(`Rule ${JSON.stringify(e)} not allow`)})}catch(e){throw e}}_ruleSimple(e,r){try{var n={$in:[e]};return this._ruleCompose(n,r)}catch(e){throw e}}_ruleCompose(e,r){const n=this;try{var[t]=Object.keys(e);if(!n._ruleTypeAllowed(t))throw new ErrorPermissionEngine("Rule type not allow!");const i=e[t],s={type_$in:()=>n._ruleType$in(i,r),type_$nin:()=>!n._ruleType$in(i,r),type_$and:()=>n._ruleType$and(i,r),type_$not:()=>!n._ruleType$and(i,r),type_$regex:()=>n._ruleType$regex(i,r)};return s[`type_${t}`]()}catch(e){throw e}}_checkRoles(e,r){try{var n=this._isArray(e)&&0<e.length,t=this._isArray(r)&&0<r.length;if(!n||!t)throw new ErrorPermissionEngine("Fail, roles or userRoles is empty, verify roles and try again");return!0}catch(e){throw e}}canAccess(r,e){var n=this;try{n._checkRoles(r,e);const t=[];for(const i of e){let e=!1;if(n._isString(i))e=n._ruleSimple(i,r);else{if(!n._isObject(i))throw new ErrorPermissionEngine(`Rule type ${typeof i} not allow`);e=n._ruleCompose(i,r)}t.push(e)}return[...new Set(t)].every(e=>e)}catch(e){throw e}}}const ErrorPermissionEngine$1=ErrorPermissionEngine;export default PermissionEngine;export{ErrorPermissionEngine$1 as ErrorPermissionEngine};
