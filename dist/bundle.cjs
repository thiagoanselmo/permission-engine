"use strict";class Base{constructor(){this._allowedOperators=["$in","$nin","$regex","$and","$not"]}_ruleTypeAllowed(e){return this._allowedOperators.includes(e)}_isString(e){return"string"==typeof e}_isObject(e){return!Array.isArray(e)&&"object"==typeof e}_isArray(e){return Array.isArray(e)}_isRuleType(e,r){try{return this._isObject(r)&&e in r}catch(e){throw e}}}class PermissionEngine extends Base{constructor(){super()}_ruleType$regex(r,e){try{return e.some(e=>r.test(e))}catch(e){throw e}}_ruleType$in(e,r){const t=this;try{return e.some(e=>{if(t._isString(e))return r.includes(e);if(t._isRuleType("$regex",e))return t._ruleType$regex(e.$regex,r);throw new Error(`Rule ${JSON.stringify(e)} not allow`)})}catch(e){throw e}}_ruleType$and(e,r){const t=this;try{return e.every(e=>{if(t._isString(e))return r.includes(e);if(t._isRuleType("$in",e))return t._ruleType$in(e.$in,r);if(t._isRuleType("$nin",e))return!t._ruleType$in(e.$nin,r);if(t._isRuleType("$and",e))return t._ruleType$and(e.$and,r);if(t._isRuleType("$not",e))return!t._ruleType$and(e.$not,r);if(t._isRuleType("$regex",e))return t._ruleType$regex(e.$regex,r);throw new Error(`Rule ${JSON.stringify(e)} not allow`)})}catch(e){throw e}}_ruleSimple(e,r){try{var t={$in:[e]};return this._ruleCompose(t,r)}catch(e){throw e}}_ruleCompose(e,r){const t=this;try{var[n]=Object.keys(e);if(!t._ruleTypeAllowed(n))throw new Error("Rule type not allow!");const s=e[n],i={type_$in:()=>t._ruleType$in(s,r),type_$nin:()=>!t._ruleType$in(s,r),type_$and:()=>t._ruleType$and(s,r),type_$not:()=>!t._ruleType$and(s,r),type_$regex:()=>t._ruleType$regex(s,r)};return i[`type_${n}`]()}catch(e){throw e}}_checkRoles(e,r){try{var t=this._isArray(e)&&0<e.length,n=this._isArray(r)&&0<r.length;if(!t||!n)throw new Error("Roles not valid, verify roles and try again");return!0}catch(e){throw e}}canAccess(r,e){var t=this;try{t._checkRoles(r,e);const n=[];for(const s of e){let e=!1;t._isString(s)?e=t._ruleSimple(s,r):t._isObject(s)?e=t._ruleCompose(s,r):console.error(`Rule type ${typeof s} not allow`),n.push(e)}return[...new Set(n)].every(e=>e)}catch(e){throw console.error("Fail in method canAccess",e.name||"not have name",e.message||"not have message"),e}}}module.exports=PermissionEngine;
